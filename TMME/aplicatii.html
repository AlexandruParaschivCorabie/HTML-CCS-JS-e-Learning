<html>
<title >
    Backtracking
</title>

<link href="foi de stil in cascada/general.css" rel="stylesheet" type="text/css"/></link>
<link href="foi de stil in cascada/aplicatii.css" rel="stylesheet" type="text/css"/></link>

<head>
    <h1 class="titlu">Backtracking</h1>    
</head>


<body>

<div class="baraNavigare">
    <a  href="acasa.html">ACASA</a>
    <a href="implementare.html">IMPLEMENTARE</a>
    <a href="exemple.html">EXEMPLE</a>
    <a class="active" href="aplicatii.html">APLICATII</a>
    <a href="javascript.html">JAVASCRIPT</a>
    <a href="quiz.html">QUIZ</a>
        <a href="simulare.html">SIMULARE</a>
</div>


<p class="aplicatiiTitluri">
Aplicatia 1.
</p>

<p class="paragraf">
Problema turelor. Se cede afiÈ™area tuturor modurilor de aplasa n ture, pe o tablÄƒ de È™ah nXn aÈ™a Ã®ncÃ¢t
oricare douÄƒ sÄƒ nu se atace. CunoaÈ™tem cÄƒ pe o tablÄƒ de È™ah douÄƒ ture se atacÄƒ dacÄƒ sunt plasate pe
aceeaÈ™i linie sau pe aceeaÈ™i coloanÄƒ. De exemplu, pentru n=3 avem soluÈ›iile:
<br>
<br>
Rezolvare:
La prima vedere problema este total atipicÄƒ faÈ›Äƒ de ce am studiat deja. Noi È™tim sÄƒ generÄƒm soluÈ›ii sub formÄƒ
de vector È™i aici avem de-a face cu ceva Ã®n douÄƒ dimensiuni. Facem Ã®nsÄƒ urmÄƒtoarea observaÈ›ie: pe o linie nu
pot fi douÄƒ ture, deci pentru o linie am putea sÄƒ memorÄƒm coloana turei care se aflÄƒ pe acea linie. Ajungem
aÈ™adar la un vector acum Ã®n care x[i] reprezintÄƒ coloana turei care se aflÄƒ pe linia i. AdicÄƒ Ã®n vectorul soluÈ›ie
de la backtracking, indicii ar reprezenta linii de pe tabla de È™ah iar valorile ar reprezenta coloane. Ne-am
asigurat pÃ¢nÄƒ acum de linii distincte Ã®ntrucÃ¢t o componentÄƒ a unui vector poate avea o singurÄƒ valoare È™i cum
aceasta reprezintÄƒ coloana corespunzÄƒtore liniei reprezentatÄƒ de componentÄƒ, asigurÄƒm unicitatea turelor pe
linii. Acum ne mai rÄƒmÃ¢ne doar sÄƒ punem condiÈ›ia sÄƒ nu avem douÄƒ ture pe aceeaÈ™i coloanÄƒ. Se vede repede
cÄƒ asta este echivalent sÄƒ impunem ca elementele din vector sÄƒ fie distincte (valorile Ã®nseamnÄƒ indici de
coloane). AÈ™adar problema noastrÄƒ este absolut identicÄƒ cu aceea de generare a permutÄƒrilor. Ne putem alege
Ã®nsÄƒ modul de afiÈ™ase È™i iatÄƒ de putem obÈ›ine:

</p>

<img  src="imagini/ture.png" alt="2 imagini o tabla de sah 4x4 si 4 ture plasate in pozitia in car nu se ataca" class="turePNG">


<pre class="cod">
    Cod:
        for (i=1;i<=n;i++)
    cout<<â€™(â€™,i,â€™,â€™,x[i],â€™)â€™;
    cout<<â€\nâ€;
        for (i=1;i<=n;i++) {
            for (j=1;j<=n;j++)
            if (x[i] == j)
            cout<<"T";
            else
            cout<<"*";
            cout<<"\n";
            }
    cout<<"\n";
    </pre>

<p class="aplicatiiTitluri">
        Aplicatia 2.
</p>

<p class="paragraf">


Problema damelor. Se cere afiÈ™area tuturor modurilor de aplasa n dame, pe o tablÄƒ de È™ah nXn aÈ™a
Ã®ncÃ¢t oricare douÄƒ sÄƒ nu se atace. CunoaÈ™tem cÄƒ pe o tablÄƒ de È™ah douÄƒ dame se atacÄƒ dacÄƒ sunt
plasate pe aceeaÈ™i linie, pe aceeaÈ™i coloanÄƒ sau pe aceeaÈ™i diagonalÄƒ. De exemplu, pentru n=3 nu
avem soluÈ›ii, dar pentru n=4 le avem pe urmÄƒtoarele douÄƒ:
<br>
<br>
Rezolvare
AceastÄƒ problemÄƒ este foarte asÄƒmÄƒnÄƒtoare cu aceea a turelor, mulÈ›imea soluÈ›iilor sale fiind inclusÄƒ Ã®n
mulÈ›imea soluÈ›iilor de la ture. CondiÈ›ia suplimentarÄƒ, aceea ca oricare douÄƒ dame sÄƒ nu se atace pe diagonalÄƒ
este:
<br>
<br>
|ğ‘ğ‘ğ‘  âˆ’ ğ‘–| â‰  |ğ‘¥[ğ‘ğ‘ğ‘ ] âˆ’ ğ‘¥[ğ‘–]|
<br>
<br>
DacÄƒ douÄƒ dame s-ar afla pe aceeaÈ™i â€œdiagonalÄƒâ€ ar Ã®nsemna cÄƒ se formeazÄƒ un â€œtriunghi dreptunghic isoscelâ€
ca Ã®n figurÄƒ.
<br>
<img  src="imagini/diagonala.PNG" alt=" imagine cu o tabla de sah 3x3 si 3 ture plasate in pozitia in car nu se ataca" class="diagonalaPNG">
<br>
Lungimile laturilor sale sunt date de diferenÈ›a liniilor È™i a coloanelor pentru punctele pe care le ocupÄƒ. Noi am
folosit aveste valori Ã®n modul pentru a prinde toate cazurile care pot apÄƒrea pentru dispunerea celor douÄƒ
puncte.
<br>
<br>
Vom pÄƒstra testul cu vectori de frecvenÈ›Äƒ pentru elemente distincte È™i vom pune Ã®n verif testul pentru
diagonale. Facem Ã®nsÄƒ observaÈ›ia cÄƒ este posibilÄƒ optimizarea cu vectori de frecvenÈ›Äƒ È™i pentru testul de
diagonale, dacÄƒ È›inem cont cÄƒ elementele de pe aceeaÈ™i paralelÄƒ la diagonala principalÄƒ a unei matrice
pÄƒtratice au diferenÈ›a indicilor constantÄƒ iar cele de pe aceeaÈ™i paralelÄƒ la diagonala secundarÄƒ au suma
indicilor constantÄƒ. LÄƒsÄƒm aceastÄƒ optimizare ca exerciÈ›iu.

</p>

<pre class="cod2">

    #include <iostream>
    using namespace std;
    int n;
    int x[30], f[30];
    int modul(int x) {
        return x > 0 ? x : -x;
}
int verif (int pas) {
    /// la pas-i nu am mai pus modul intrucat noi testam
    /// in urma si atunci sigur avem pas>i
    for (int i=1;i < pas;i++)
        if (pas-i == modul(x[pas]-x[i]))
            return 0;
    return 1;
}
void backtrack(int pas) {
    if (pas == n+1) {
        for (int i=1;i<=n;i++) {
            for (int j=1;j<=n;j++)
                if (x[i] == j)
                    cout<<"D";
                else
                    cout<<"*";
                cout<<"\n";
            }
            cout<<"\n";
        } else
            for (int i=1;i<=n;i++) {
                if (f[i] == 0) {
                    x[pas] = i;
                    f[i] = 1;
                    if (verif(pas))
                        backtrack(pas+1);
                    f[i] = 0;
                }
            }
}
int main () {
    cin>>n;
    backtrack(1);
}
</pre>

<img  src="imagini/regine.png" alt="" class="turePNG">

<br>
<br>
<br>

</body>
</html>